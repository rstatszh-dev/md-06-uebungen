---
title: "Vektoren für Iteration in R"
format:
  html:
    embed-resources: true
    toc: true
execute:
  warning: false
editor_options:
  chunk_output_type: console
editor: visual
---

```{r}
library(tidyverse)
library(readxl)
```

# Warum Vektoren für Iteration?

In dieser Übung lernst du, wie Vektoren verwendet werden, um Code wiederverwendbar zu machen. Dies ist besonders nützlich, wenn du mehrere Dateien einlesen oder mehrere ähnliche Operationen durchführen musst.

## Aufgabe 1: Das Problem - Repetitiver Code

In dem Ordner `daten/gapminder` befinden sich 12 Excel-Dateien, eine für jedes Jahr von 1952 bis 2007 (in 5-Jahres-Intervallen). Jede Datei enthält die gleichen Spalten: `country`, `continent`, `lifeExp`, `pop`, `gdpPercap`.

**Schlechter Ansatz:** Jede Datei einzeln einlesen und dann kombinieren:

```{r}
#| eval: false

data1952 <- read_excel("daten/gapminder/1952.xlsx")
data1957 <- read_excel("daten/gapminder/1957.xlsx")
data1962 <- read_excel("daten/gapminder/1962.xlsx")
# ... noch 9 weitere Male copy-paste ...

gapminder <- bind_rows(data1952, data1957, data1962, ...) # usw.
```

**Beantworte folgende Fragen:**

1.  Wie oft müsstest du den Code kopieren und einfügen, um alle 12 Dateien einzulesen?

2.  Was passiert, wenn du später herausfindest, dass du noch eine zusätzliche Spalte mit `mutate()` hinzufügen musst? Wie viele Zeilen musst du ändern?

3.  Was passiert, wenn es 50 Dateien sind statt 12?

**Antworten:**

1.  12 Mal - einmal für jede Datei.

2.  Ich müsste 12 Zeilen ändern - eine für jede Datei. Das ist fehleranfällig und zeitaufwändig.

3.  Der Ansatz wird völlig unpraktisch. Es wäre unmöglich, 50 Mal copy-paste zu machen und dabei keine Fehler zu machen.

## Aufgabe 2: Die Lösung - Einen Vektor von Dateinamen erstellen

Anstatt jeden Dateinamen manuell zu schreiben, erstellen wir einen **Vektor** mit allen Dateinamen und iterieren darüber.

```{r}
# Erstelle einen Vektor mit allen Excel-Dateinamen im gapminder Ordner
filenames <- list.files("daten/gapminder",
                       pattern = ".xlsx",
                       full.names = TRUE)

# Betrachte den Vektor
filenames
```

**Beantworte folgende Fragen:**

1.  Welcher Typ ist der `filenames` Vektor? (Tipp: Nutze `typeof()`)

```{r}
typeof(filenames)
```

2.  Wie viele Elemente hat der Vektor? (Tipp: Nutze `length()`)

```{r}
length(filenames)
```

3.  Was steht im ersten Element? Was steht im fünften Element? (Tipp: Nutze `filenames[[1]]` und `filenames[[5]]`)

```{r}
filenames[[1]]
filenames[[5]]
```

**Teste das Einlesen einer Datei:**

```{r}
# Lese die erste Datei ein
read_excel(filenames[[1]])
```

**Frage:** Funktioniert es? Was siehst du in der Ausgabe?

**Antwort:** Ja, es funktioniert! Ich sehe die Daten aus dem Jahr 1952 mit den Spalten country, continent, lifeExp, pop und gdpPercap für alle Länder.

## Aufgabe 3: Metadaten aus dem Dateinamen-Vektor extrahieren

Jede Datei repräsentiert ein Jahr (z.B. "1952.xlsx", "1957.xlsx"), aber diese Information ist **nicht in den Daten selbst**. Wir müssen das Jahr aus dem Dateinamen extrahieren und später als Spalte hinzufügen.

```{r}
# Extrahiere die Jahreszahlen aus den Dateinamen
years <- str_extract(filenames, "\\d{4}")

# Betrachte den Vektor
years
```

**Info:** `\\d{4}` ist ein "regular expression pattern":

-   `\\d` steht für eine beliebige Ziffer (0-9)
-   `{4}` bedeutet "genau viermal"
-   Also passt `\\d{4}` auf jede Sequenz von genau vier Ziffern

**Aufgaben:**

1.  Welcher Typ ist der `years` Vektor?

```{r}
typeof(years)
```

2.  Haben `filenames` und `years` die gleiche Länge? Überprüfe mit `length()`.

```{r}
length(filenames)
length(years)

# Sind sie gleich?
length(filenames) == length(years)
```

3.  Fülle die Lücken im Code aus, um die Verbindung zwischen den Vektoren zu testen:

```{r}
# Der erste Dateiname
filenames[[1]]

# Das erste Jahr
years[[1]]

# Der fünfte Dateiname
filenames[[5]]

# Das fünfte Jahr
years[[5]]
```

**Wichtig:** `filenames[[i]]` und `years[[i]]` gehören zusammen - das ist der Schlüssel für die Iteration!

## Aufgabe 4: Iteration - Alle Dateien einlesen und Metadaten hinzufügen

Jetzt nutzen wir eine **for-Schleife**, um über die Dateinamen zu iterieren.

**Schritt 1: Verstehe seq_along()**

```{r}
# Erstelle eine Sequenz von Indizes
seq_along(filenames)
```

**Frage:** Was macht `seq_along(filenames)`? Beschreibe in eigenen Worten:

**Antwort:** `seq_along(filenames)` erstellt eine Sequenz von Zahlen von 1 bis zur Länge des Vektors (in diesem Fall 1 bis 12). Dies gibt uns die Indizes, die wir brauchen, um über den Vektor zu iterieren.

**Schritt 2: Fülle die Lücken aus, um alle Dateien einzulesen**

```{r}
# Erstelle eine leere Liste für die Ergebnisse
data_list <- list()

# Iteriere über die Indizes
for (i in seq_along(filenames)) {

  # Lese die i-te Datei ein
  data_list[[i]] <- read_excel(filenames[[i]]) |>
    mutate(year = years[[i]]) |>              # Füge das i-te Jahr hinzu
    relocate(year, .after = continent)

}

# Betrachte das zweite Element der Liste
data_list[[2]]
```

**Fragen:**

1.  Was passiert während der Schleife läuft?

**Antwort:** Die Schleife läuft 12 Mal. Bei jeder Iteration wird eine Excel-Datei eingelesen, eine year-Spalte hinzugefügt, und das Ergebnis wird in der Liste `data_list` gespeichert.

2.  Was ist in `data_list` gespeichert? (Tipp: Schaue im Environment nach)

**Antwort:** `data_list` ist eine Liste mit 12 Elementen. Jedes Element ist ein Dataframe mit den Daten eines bestimmten Jahres.

3.  Wie viele Dataframes sind in der Liste?

**Antwort:** 12 Dataframes - einer für jedes Jahr von 1952 bis 2007.

**Schritt 4: Kombiniere alle Dataframes zu einem**

```{r}
# Kombiniere alle Dataframes in der Liste zu einem grossen Dataframe
gapminder_all <- bind_rows(data_list)

# Betrachte das Ergebnis
gapminder_all
```

## Aufgabe 5: Überprüfe dein Ergebnis

Jetzt hast du alle 12 Dateien eingelesen und zu einem Dataframe kombiniert!

**Überprüfungen:**

1.  Wie viele Zeilen hat `gapminder_all`? (Tipp: Nutze `nrow()`)

```{r}
nrow(gapminder_all)
```

2.  Wie viele einzigartige Jahre gibt es? (Tipp: Nutze `count(gapminder_all, year)`)

```{r}
gapminder_all |>
  count(year)
```

3.  Hast du alle Jahre von 1952 bis 2007 in 5-Jahres-Intervallen?

```{r}
# Überprüfe die Jahre
gapminder_all |>
  distinct(year) |>
  arrange(year)
```

**Antwort:** Ja! Wir haben alle 12 Jahre: 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, 2002, 2007.

## Reflexion

**Beantworte folgende Fragen:**

1.  Wie viele Zeilen Code musstest du ändern, um alle 12 Dateien einzulesen (im Vergleich zum copy-paste Ansatz)?

**Antwort:** Mit dem Iterations-Ansatz musste ich nur die for-Schleife einmal schreiben (ca. 6 Zeilen Code). Beim copy-paste Ansatz hätte ich mindestens 24 Zeilen gebraucht (12 für read_excel + 12 für bind_rows). Wenn ich später etwas ändern muss, ändere ich nur eine Stelle statt 12.

2.  Was passiert, wenn du eine neue Datei `2012.xlsx` zum Ordner hinzufügst? Musst du den Code ändern?

**Antwort:** Nein! Der Code würde automatisch die neue Datei einlesen, weil `list.files()` alle Dateien im Ordner findet. Das ist der grosse Vorteil von Iteration - der Code passt sich automatisch an.
